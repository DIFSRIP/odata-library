"use strict";

/* eslint max-params: [1, 6] */

const request = require("superagent");
const _ = require("lodash");
const url = require("./url");
const BatchManager = require("./batch/Manager");
const parsers = require("./parsers");

/**
 * Service endpoint agent.
 * Handles all GET/POST/PUT/DELETE ... methods to the service endpoint.
 *
 * @class Agent
 */

class Agent {
  /**
   * Creates an instance of <code>Agent</code>.
   *
   * @param {Object} settings define service endpoint
   *
   * @memberof Agent
   */
  constructor(settings) {
    Object.defineProperty(this, "logger", {
      value: this.initializeLogger(settings),
      writable: false,
    });

    Object.defineProperty(this, "settings", {
      value: settings,
      writable: false,
    });

    Object.defineProperty(this, "prefix", {
      value: settings.url.replace(/\/$/, ""),
      writable: false,
    });

    Object.defineProperty(this, "superagent", {
      value: this.initializeAgent(settings),
      writable: false,
    });

    Object.defineProperty(this, "batchManager", {
      value: new BatchManager(),
      writable: false,
    });
  }

  static get authenticators() {
    return [
      "./authentication/samlSap",
      "./authentication/basic",
      "./authentication/none",
    ];
  }

  /**
   * Initialize logger instance
   *
   * @param {Object} settings define service endpoint
   *
   * @returns {Object} object which implements trace, debug, info, warn, error methods.
   *
   * @memberof Agent
   */
  initializeLogger(settings) {
    let logger = {
      trace: () => {},
      debug: () => {},
      info: () => {},
      warn: () => {},
      error: () => {},
    };
    let methods = _.keys(logger);

    if (_.has(settings, "logger")) {
      _.each(methods, (methodName) => {
        if (!_.isFunction(_.get(settings, `logger.${methodName}`))) {
          throw new Error(
            `Cannot initialize logger: ${methodName} is not a function`
          );
        }
      });
      logger = settings.logger;
    }
    return logger;
  }

  /**
   * Initialize superagent library
   *
   * @param {Object} settings define service endpoint
   *
   * @returns {superagent} internally used superagent instance
   *
   * @memberof Agent
   */
  initializeAgent(settings) {
    let superagent = request.agent();

    if (settings.ca) {
      superagent.ca(settings.ca);
    }

    this.logger.info("Agent correctly initialized.");

    return superagent;
  }

  /**
   * Format  superagent error to normal Error object
   *
   * @static
   *
   * @param {Request} superAgentError object generated by superagent which contains HTTP error informtions
   *
   * @return {Error} javascript Error object with HTTP error explanation
   *
   * @memberof Agent
   */
  static formatResponseError(superAgentError) {
    let httpInfo;
    let requestUrl;
    let cookies;
    let headers;
    let message;
    let error = new Error(`${superAgentError.message}\n\n${httpInfo}`);

    if (superAgentError.response) {
      requestUrl = _.get(superAgentError, "response.request.url");
      headers = JSON.stringify(
        _.get(superAgentError, "response.request.header"),
        null,
        2
      );
      cookies = JSON.stringify(
        _.get(superAgentError, "response.request.cookies").split(";"),
        null,
        2
      );
      httpInfo = [
        `URL : ${requestUrl}`,
        `\nHeaders : ${headers}`,
        `\nCookies : ${cookies}`,
      ].join("\n");
      message = Agent.parseNetweaverErrorMessage(
        _.get(superAgentError, "response.text") ||
          _.get(superAgentError, "response.error.message") ||
          ""
      );
      error = new Error(
        `${superAgentError.message}${
          message ? " - " + message : ""
        }\n\n${httpInfo}`
      );
      error.response = _.get(superAgentError, "response");
    }

    return error;
  }

  /**
   * Send informations about response and  request to the logger
   *
   * @param {Object} res response from the HTTP server
   *
   * @memberof Agent
   */
  logResponse(res) {
    let req = res.request;
    let requestHeaders = JSON.stringify(_.get(req, "header"), null, 2);
    let cookies = JSON.stringify(_.get(req, "cookies"), null, 2);
    let responseHeaders = JSON.stringify(_.get(res, "header"), null, 2);
    let body = JSON.stringify(_.get(res, "body"), null, 2);
    let statusCode = _.get(res, "statusCode");

    this.logger.debug(`Request headers : ${requestHeaders}`);
    this.logger.info(`Response Status Code : ${statusCode}`);
    this.logger.debug(`Response Headers : ${responseHeaders}`);
    this.logger.debug(`Cookies : ${cookies}`);
    this.logger.debug(`Response : ${body}`);
  }

  logRequest(requestURL, method, payload) {
    this.logger.info(
      `Request:\n  ${method} ${requestURL}\n  Request Payload: ${
        payload ? JSON.stringify(payload, null, 2) : "Empty"
      }`
    );
  }

  /**
   * Parse body of the error response from Netweaver server
   *
   * @static
   *
   * @param {String} responseText is response text from Netweaver server
   *
   * @return {String} parse message
   *
   * @memberof Agent
   */
  static parseNetweaverErrorMessage(responseText) {
    let errorMessageText;
    let parsedError;

    try {
      parsedError = JSON.parse(responseText);
      errorMessageText = [];
      if (_.has(parsedError, "error.message.value")) {
        errorMessageText.push(_.get(parsedError, "error.message.value"));
      }
      errorMessageText.push(JSON.stringify(parsedError, null, 2));
      errorMessageText = errorMessageText.join("\n\n");
    } catch (err) {
      errorMessageText = responseText;
    }

    return errorMessageText;
  }

  /**
   * Convert parameters map to query string
   *
   * @param {Object} parameters - contains information which is user to request metadata
   *
   * @returns {String} search part of the metadata URL
   *
   * @memberof Agent
   */
  metadataSearch(parameters) {
    return _.chain(parameters)
      .keys()
      .filter(
        (key) =>
          _.isArray(parameters[key]) ||
          _.isString(parameters[key]) ||
          _.isNumber(parameters[key])
      )
      .map(
        (key) =>
          `${key}=${
            _.isArray(parameters[key])
              ? parameters[key].join(",")
              : parameters[key]
          }`
      )
      .join("&")
      .value();
  }

  /**
   * Send requests to service metadata
   *
   * @returns {Promise} which done when all metadata requests ar loaded and metadata is merged.
   *
   * @memberof Agent
   */
  metadata() {
    let metadataUrls = _.concat(
      //Core metadata data url
      [
        `${this.prefix}/$metadata?${this.metadataSearch(
          this.settings.parameters
        )}`,
      ],
      //Add metadata url if exists
      this.settings.annotationsUrl
        ? url.appendSearch(
            this.settings.annotationsUrl,
            this.metadataSearch(this.settings.parameters)
          )
        : []
    );

    return this.authenticate(metadataUrls[0]).then(() => {
      return Promise.all(
        _.map(metadataUrls, (requestUrl) =>
          this.createMetadataRequest(requestUrl)
        )
      ).then((responses) => {
        this.logger.info("All metadata succesfully fetched.");
        return _.map(responses, (response) => response.body);
      });
    });
  }

  /**
   * Creates metadata requests from url
   *
   * @param {string} metadataUrl URL of the metadata
   *
   * @returns {Promise} which done where metadata request is loaded
   *
   * @memberof Agent
   */
  createMetadataRequest(metadataUrl) {
    this.logRequest(metadataUrl, "GET");

    //Envelope superagent "promise" by standard promise
    //because superagent "promise" does not support, multiple
    //"then" calls.
    return new Promise((resolve, reject) => {
      this.superagent
        .get(metadataUrl)
        .buffer(true)
        .then((res) => {
          this.logger.info(
            `Metadata successfully fetched from '${metadataUrl}'.`
          );
          this.logResponse(res);
          resolve(res);
        })
        .catch((err) => {
          reject(Agent.formatResponseError(err));
        });
    });
  }

  /**
   * Wrapper around GET function. All parameters are passed to superagent
   *
   * @param {String} inputUrl relative path in the service
   * @param {Object} headers object which contains headers used for the GET request
   *
   * @returns {Promise} promise which is done when GET request is finished
   *
   * @memberof Agent
   */
  get(...args) {
    return this.sendRequest("GET", ...args);
  }

  /**
   * Wrapper around POST function. All parameters are passed to superagent
   *
   * @param {String} inputUrl relative path in the service
   * @param {Object} headers object which contains headers used for the post request
   * @param {Object} payload data which is converted to the JSON string and passed as body of POST request
   *
   * @returns {Promise} promise which is done when POST request is finished
   *
   * @memberof Agent
   */
  post(...args) {
    return this.sendRequest("POST", ...args);
  }

  /**
   * Wrapper around PUT function. All parameters are passed to superagent
   *
   * @param {String} inputUrl relative path in the service
   * @param {Object} headers object which contains headers used for the PUT request
   * @param {Object} payload data which is converted to the JSON string and passed as body of PUT request
   *
   * @returns {Promise} promise which done when PUT request is finished
   *
   * @memberof Agent
   */
  put(...args) {
    return this.sendRequest("PUT", ...args);
  }

  /**
   * Wrapper around superagent http requests. All parameters are passed to superagent
   *
   * @private
   *
   * @param {String} httpMethod name of the HTTP method
   * @param {String} inputUrl relative path in the service
   * @param {Object} headers object which contains headers used for the post request
   * @param {Object} payload data which is converted to the JSON string and passed as body of POST request
   * @param {Boolean} buffer use buffer to catch body (request is resolved when all data are fetched from OData service)
   *
   * @returns {Promise} which done when request of HTTP method definned by parameters has finished
   *
   * @memberof Agent
   */
  sendRequest(httpMethod, inputUrl, headers, payload, buffer = false) {
    let requestURL = `${url.normalize(inputUrl, this.prefix)}`;
    let requestMethod = this.superagent[httpMethod.toLowerCase()](requestURL);

    requestMethod.buffer(buffer);

    this.logRequest(requestURL, httpMethod.toUpperCase(), payload);

    let promise = new Promise((resolve, reject) => {
      if (payload) {
        requestMethod.send(payload);
      }

      this.headersToRequest(headers, requestMethod)
        .then((res) => {
          this.logResponse(res);
          resolve(res);
        })
        .catch((err) => {
          reject(Agent.formatResponseError(err));
        });
    });
    promise.request = requestMethod;

    return promise;
  }

  /**
   * Send batch request defined by the batch object passed as parameter
   *
   * @private
   *
   * @param {Object} [batch] represents batch request, if batch is not
   *        passed use default batch from batch/Manager
   * @param {Boolean} raw if the parameter is false response contains
   *        just array of parsed OData responses. If the parameter is true
   *        response contains HTTP.Response with property batchResponse.
   *        The batchResponses contains list of particular respones from
   *        the requests send over bulk batch request.
   *
   * @returns {Promise} which done when batch request is resolved
   *
   * @memberof Agent
   */
  batch(batch, raw = false) {
    let batchNormalized = batch || this.batchManager.defaultBatch;
    let payload;

    return new Promise((resolve, reject) => {
      let handlerError = (err) => {
        reject(err);
      };
      this.fetchToken()
        .then((csrfToken) => {
          payload = batchNormalized.payload(csrfToken);
          let promise = this.sendRequest(
            "POST",
            "/$batch",
            {
              "x-csrf-token": csrfToken,
              "Content-Type": `multipart/mixed;boundary=${batchNormalized.boundary()}`,
              Accept: "multipart/mixed",
            },
            payload,
            true
          );

          promise.request._parser = parsers["text/plain"];
          promise
            .then((batchResponse) => {
              batchNormalized
                .process(batchResponse)
                .then((requestsResponses) => {
                  let normalizedResponse = this.normalizeBatchResponse(
                    batchResponse,
                    requestsResponses,
                    raw
                  );
                  this.batchManager.remove(batchNormalized);
                  resolve(normalizedResponse);
                })
                .catch(handlerError);
            })
            .catch(handlerError);
        })
        .catch(handlerError);
    });
  }

  /**
   * Wrapper around MERGE function. All parameters are passed to superagent
   *
   * @param {String} inputUrl relative path in the service
   * @param {Object} headers object which contains headers used for the MERGE request
   * @param {Object} payload data which is converted to the JSON string and passed as body of MERGE request
   *
   *
   * @returns {Promise} promise which done when MERGE request has finished
   *
   * @memberof Agent
   */
  merge(...args) {
    return this.sendRequest("MERGE", ...args);
  }

  /**
   * Wrapper around DELETE function. All parameters are passed to superagent method
   *
   * @param {String} inputUrl relative path in the service
   * @param {Object} headers object which contains headers used for the delete request
   *
   * @returns {Promise} which is done where delete request has done
   *
   * @memberof Agent
   */
  delete(inputUrl, headers) {
    return this.sendRequest("DELETE", inputUrl, headers);
  }

  /**
   * Send request to fetch CSRF token from backend.
   *
   * @param {String} inputUrl relative path in the service
   *
   * @returns {Promise} which done where token has loaded
   *
   * @memberof Agent
   */
  fetchToken() {
    let promise;
    if (this.csrfToken) {
      promise = Promise.resolve(this.csrfToken);
    } else {
      promise = new Promise((resolve, reject) => {
        this.logger.info("Fetch X-CSRF-Token");
        this.sendRequest("GET", "/", {
          "X-CSRF-Token": "fetch",
        })
          .then((res) => {
            this.csrfToken = res.headers["x-csrf-token"];
            this.logger.info("CSRF token successfully downloaded.");
            resolve(this.csrfToken);
          })
          .catch(reject);
      });
    }
    return promise;
  }

  headersToRequest(headers, req) {
    _.forEach(headers, (value, key) => {
      req.set(key, value);
    });
    return req;
  }

  /**
   * Authenticate user by authenticators. Authenticators are modules
   * in lib/agent/authentication/. List of modules is in Agent.authenticators
   * array. Authenticate method calls authenticators in order of list.
   * User is authenticated when first authenticator succeed.
   *
   * @param {String} endpointUrl url of metadata, which is used as
   *        root of service
   *
   * @return {Promise} promise which is resolve when first authenticator succeed
   *        or reject if all authenticators fails
   *
   * @memberof Agent
   */
  authenticate(endpointUrl) {
    return new Promise((resolve, reject) => {
      let authenticator;
      if (_.isArray(Agent.authenticators) && Agent.authenticators.length > 0) {
        authenticator = require(Agent.authenticators[0]);
        this.logger.debug(
          `Try to authenticate over ${authenticator.authenticatorName} authenticator.`
        );
        this.tryAuthenticator(
          1,
          endpointUrl,
          authenticator(this.settings, this.superagent, endpointUrl),
          resolve,
          reject
        );
      } else {
        reject(new Error("Authenticators are not defined."));
      }
    });
  }

  /**
   * Try authenticate user by particular authenticator. If authenticator
   * fails try to use next authenticator from Agent.authenticators list.
   * If all authenticators fails call callBackError parameter if any
   * authenticator succeed call callBack parameter
   *
   * The method is used internally in the public authenticated method
   *
   * @private
   *
   * @param {Number} index to the Agent.authenticators which is used
   * @param {String} endpointUrl url of metadata, which is used as
   *        root of service
   * @param {Promise} previousAuthenticatorPromise determine previous
   *        authenticator result
   * @param {Function} callBack called when authenticator succeed
   * @param {Promise} callBackError called when all authenticators
   *        fails
   *
   * @memberof Agent
   */
  tryAuthenticator(
    index,
    endpointUrl,
    previousAuthenticatorPromise,
    callBack,
    callBackError
  ) {
    let previousAuthenticator;
    let authenticator;

    previousAuthenticator = require(Agent.authenticators[index - 1]);
    previousAuthenticatorPromise
      .then((response) => {
        this.logger.debug(
          `Authenticator ${previousAuthenticator.authenticatorName} succeed.`
        );
        callBack(response);
      })
      .catch((err) => {
        let fatalError = this.fatalAuthenticateError(
          err,
          previousAuthenticator
        );
        if (fatalError) {
          callBackError(fatalError);
        } else {
          this.logger.warn(
            `Authenticator ${previousAuthenticator.authenticatorName} failed.`,
            err
          );
          if (index < Agent.authenticators.length) {
            authenticator = require(Agent.authenticators[index]);
            this.logger.debug(
              `Try to authenticate over ${authenticator.authenticatorName} authenticator.`
            );
            this.tryAuthenticator(
              ++index,
              endpointUrl,
              authenticator(this.settings, this.superagent, endpointUrl),
              callBack,
              callBackError
            );
          } else {
            callBackError(
              new Error(`Not valid authenticator found - ${err.message}.`)
            );
          }
        }
      });
  }

  /**
   * Try authenticate user by particular authenticator. If authenticator
   * fails try to use next authenticator from Agent.authenticators list.
   * If all authenticators fails call callBackError parameter if any
   * authenticator succeed call callBack parameter
   *
   * The method is used internally in the public authenticated method
   *
   * @private
   *
   * @param {Error} resError error based on the response
   * @param {Object} previousAuthenticator authenticator object
   *
   * @returns {Error} returns object with fatal error which steps authentication
   *
   * @memberof Agent
   */
  fatalAuthenticateError(resError, previousAuthenticator) {
    let fatalError;
    if (!resError.unsupported) {
      if (resError.response === undefined) {
        fatalError = new Error(
          `Authenticator ${previousAuthenticator.authenticatorName}: fatal error: ${resError}`
        );
      } else if (resError.response.forbidden) {
        fatalError = new Error(
          `Authenticator ${previousAuthenticator.authenticatorName}: forbidden: ${resError.response.res.text}`
        );
      } else if (resError.response.serverError) {
        fatalError = new Error(
          `Authenticator ${previousAuthenticator.authenticatorName}: server error: ${resError.response.res.text}`
        );
      }
    }
    return fatalError;
  }

  /**
   * Send batch request defined by the batch object passed as parameter
   *
   * @private
   *
   * @param {HTTP.Response} batchResponse response to batch request
   * @param {Object[]} requestsResponses list of responses parsed from batch response
   * @param {Boolean} raw if the parameter is false returns values contains
   * just array of parsed OData responses. If the parameter is true
   * returns batchResponse with list particular responses from batch.
   *
   * @returns {Any} array responses parsed from batch response or batch response object
   *
   * @memberof Agent
   */
  normalizeBatchResponse(batchResponse, requestsResponses, raw) {
    let normalizedBatchResponse;
    if (raw) {
      normalizedBatchResponse = _.assign(batchResponse, {
        batchResponses: requestsResponses,
      });
    } else {
      normalizedBatchResponse = _.chain([])
        .concat(...requestsResponses)
        .map((response) => {
          let oDataContent = _.get(response, this._instanceResultPath, null);
          let oDataContentArray = _.get(response, this._listResultPath);
          return _.isArray(oDataContentArray)
            ? oDataContentArray
            : oDataContent || response;
        })
        .value();
    }

    return normalizedBatchResponse;
  }

  getResultPath(isList) {
    return isList ? this._listResultPath : this._instanceResultPath;
  }

  setServiceVersion(version) {
    Object.defineProperty(this, "serviceVersion", {
      value: version,
      writable: false,
    });

    if (!["1.0", "4.0"].includes(version)) {
      throw new Error(`OData Service version '${version}' is not supported.`);
    }

    let isV4 = version === "4.0";
    Object.defineProperty(this, "_listResultPath", {
      value: isV4 ? "body.value" : "body.d.results",
      writable: false,
    });

    Object.defineProperty(this, "_instanceResultPath", {
      value: isV4 ? "body" : "body.d",
      writable: false,
    });
  }
}

_.each(parsers, (parser, mimeType) => {
  request.parse[mimeType] = parser;
});

module.exports = Agent;
